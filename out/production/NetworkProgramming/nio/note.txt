create by LZD   2018/12/04
----------------------------------------------
NIO UnBlocking IO(New IO) 同步非阻塞方式编程
    基于Reactor, 当socket有流可读/可写入socket时, 操作系统会相应的通知引用程序进行处理,
操作系统再将流读取到缓冲区/写入操作系统.
即, 此时并非BIO那样一个连接就要对应一个线程, 而是有效请求对应一个线程;
当没有数据时, 是没有工作线程在处理的.
    NIO最重要的地方是, 当一个连接创建后, 不需要对应一个线程, 这个连接会被注册到多路复用器上,
所以所有点连接只需要一个线程就可以处理, 当这个线程中的多路复用器正在轮询的时候, 发现还有请求到来,
再开启一个线程进行处理, 也就是一个线程一个请求模式【这块表述有些疑惑, 后期学习再去理解】
    在NIO的处理方式中, 当一个请求到来的话, 开启线程进行处理, 可能会等待后端应用的资源(JDBC连接等),
此时该线程就被阻塞了, 当并发程度上来的话, 也会遇到和BIO类似的问题

NIO模型图：
    https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1543918589169&di=352c88751435262a2ec409981e1a3b5b&imgtype=0&src=http%3A%2F%2Fh.hiphotos.baidu.com%2Fexp%2Fw%3D500%2Fsign%3D8470e48c580fd9f9a0175569152cd42b%2Fcaef76094b36acaf41555d0c75d98d1000e99c8d.jpg

    同步非阻塞, 服务器实现模式为一个请求对应一个通道, 即客户端发送的连接请求都会注册到多路复用器上,
多路复用器轮询到有I/O请求的时候才会开启线程进行处理.
    NIO方式适用于连接数目多且比较短(轻操作)的架构, 比如聊天服务器.
    并发局限于应用中, 编程复杂, jdk1.4开始支持.

类：
    Buffer:ByteBuffer, CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer
    Channel:SocketChannel, ServerSocketChannel
    Selector:Selector(接口), AbstractSelector(抽象类)
    SelectionKey:OP_READ, OP_WRITE, OP_CONNECT, OP_ACCEPT
===================================================================
pkt01中的服务器和客户端test对NIO的使用做了简单练习
===================================================================
pkt02中对Buffer进行了一个练习, 记录了一些重要的方法源码, 理解原理
===================================================================
pkt03中对aio编程进行了学习, 代码参考李林锋先生的《Netty权威指南》
实现服务端处理来自客户端发送的获取系统时间的请求,并进行应答的功能.